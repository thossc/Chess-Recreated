<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>chess · recreated</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            background: #1e1e1e;
            font-family: 'Inter', -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            min-height: 100vh;
            display: flex;
            align-items: center;
            justify-content: center;
            padding: 20px;
        }

        /* main container: centered, big board */
        .game-container {
            width: fit-content;
            margin: 0 auto;
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 24px;
        }

        /* account bar — minimal, dark */
        .account-bar {
            width: 100%;
            display: flex;
            align-items: center;
            justify-content: space-between;
            background: #2c2c2c;
            padding: 12px 28px;
            border-radius: 60px;
            border: 1px solid #3f3f3f;
            color: #eaeaea;
        }

        .logo {
            font-weight: 500;
            font-size: 1.4rem;
            letter-spacing: 0.5px;
            color: #dddddd;
        }

        .auth-section {
            display: flex;
            align-items: center;
            gap: 20px;
        }

        .user-badge {
            display: flex;
            align-items: center;
            gap: 12px;
            background: #3a3a3a;
            padding: 6px 16px 6px 12px;
            border-radius: 40px;
        }

        .user-icon {
            background: #6b5e4f;
            color: white;
            width: 34px;
            height: 34px;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            font-weight: 500;
            font-size: 1.2rem;
        }

        .user-name {
            font-weight: 500;
            color: #f0f0f0;
        }

        .logout-btn {
            background: none;
            border: 1px solid #5f5f5f;
            color: #ccc;
            padding: 4px 12px;
            border-radius: 30px;
            cursor: pointer;
            font-size: 0.85rem;
            transition: 0.1s;
        }
        .logout-btn:hover {
            background: #4a4a4a;
            color: white;
        }

        .auth-buttons {
            display: flex;
            gap: 12px;
        }

        .btn {
            background: #3b3b3b;
            border: 1px solid #555;
            color: #f0f0f0;
            padding: 8px 22px;
            border-radius: 40px;
            font-weight: 500;
            cursor: pointer;
            font-size: 0.95rem;
            transition: 0.1s;
        }
        .btn:hover {
            background: #4f4f4f;
            border-color: #777;
        }

        /* BIG BOARD — central, massive */
        .board-wrapper {
            background: #252525;
            padding: 30px;
            border-radius: 48px;
            box-shadow: 0 25px 40px rgba(0,0,0,0.6);
            display: flex;
            justify-content: center;
        }

        .board {
            display: grid;
            grid-template-columns: repeat(8, 1fr);
            width: min(80vh, 80vw, 700px);
            aspect-ratio: 1/1;
            border: 4px solid #4d4d4d;
            border-radius: 16px;
            overflow: hidden;
            box-shadow: 0 0 0 1px #2b2b2b;
        }

        .square {
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: min(7vh, 7vw, 52px);
            font-weight: 400;
            cursor: pointer;
            transition: background 0.08s;
            user-select: none;
            text-shadow: 2px 2px 3px rgba(0,0,0,0.4);
        }

        .square.light {
            background-color: #e9e0cf;
        }
        .square.dark {
            background-color: #7d6b58;
        }

        .square.selected {
            background-color: #b8bb7c !important;
            box-shadow: inset 0 0 0 3px #fbffc7;
        }

        /* legal move dots (minimal) */
        .square.legal-move {
            position: relative;
        }
        .square.legal-move::after {
            content: "";
            position: absolute;
            width: 22%;
            height: 22%;
            background: rgba(40, 80, 40, 0.7);
            border-radius: 50%;
            pointer-events: none;
            border: 2px solid #f5ffbe;
        }
        .square.legal-capture::after {
            width: 80% !important;
            height: 80% !important;
            border-radius: 50%;
            background: rgba(170, 70, 40, 0.5) !important;
            border: 2px solid #ffcfa2 !important;
        }

        .square.last-move {
            background-color: #9b9f5f80 !important;
            box-shadow: inset 0 0 0 2px #e5e5a0;
        }

        /* bottom bar — turn / status + captured (minimal) */
        .info-bar {
            width: 100%;
            display: flex;
            align-items: center;
            justify-content: space-between;
            background: #2a2a2a;
            border-radius: 60px;
            padding: 16px 30px;
            border: 1px solid #404040;
            color: #ddd;
            flex-wrap: wrap;
            gap: 20px;
        }

        .turn-box {
            font-size: 1.5rem;
            font-weight: 500;
            background: #1f1f1f;
            padding: 8px 28px;
            border-radius: 40px;
            border: 1px solid #555;
            letter-spacing: 0.5px;
            color: #f0d8b0;
        }

        .captured-block {
            display: flex;
            gap: 30px;
            font-size: 1.4rem;
            background: #1e1e1e;
            padding: 6px 24px;
            border-radius: 40px;
            border: 1px solid #4b4b4b;
        }

        .captured-group {
            display: flex;
            align-items: center;
            gap: 10px;
        }
        .captured-label {
            font-size: 0.9rem;
            color: #aaa;
        }
        .captured-pieces {
            display: flex;
            gap: 5px;
            flex-wrap: wrap;
        }

        .new-game-btn {
            background: #3e3e3e;
            border: 1px solid #6b6b6b;
            color: white;
            padding: 12px 30px;
            border-radius: 40px;
            font-size: 1.2rem;
            font-weight: 500;
            cursor: pointer;
            transition: 0.1s;
        }
        .new-game-btn:hover {
            background: #525252;
        }

        /* modal minimal */
        .modal {
            display: none;
            position: fixed;
            top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(0,0,0,0.7);
            backdrop-filter: blur(3px);
            align-items: center;
            justify-content: center;
            z-index: 1000;
        }
        .modal-card {
            background: #2d2d2d;
            width: 360px;
            padding: 40px 30px;
            border-radius: 48px;
            border: 1px solid #6a6a6a;
            box-shadow: 0 20px 30px black;
        }
        .modal-card h2 {
            color: #eaeaea;
            font-weight: 400;
            margin-bottom: 28px;
            text-align: center;
        }
        .modal-card input {
            width: 100%;
            padding: 16px 20px;
            background: #3f3f3f;
            border: 1px solid #6b6b6b;
            border-radius: 40px;
            margin-bottom: 20px;
            color: white;
            font-size: 1rem;
        }
        .modal-card input:focus {
            outline: none;
            border-color: #b9975e;
        }
        .modal-actions {
            display: flex;
            gap: 12px;
            justify-content: center;
        }
        .modal-actions button {
            background: #4d4d4d;
            border: none;
            color: white;
            padding: 12px 28px;
            border-radius: 40px;
            font-weight: 500;
            cursor: pointer;
            border: 1px solid #777;
        }
        .modal-actions button:hover {
            background: #666;
        }
        .error-msg {
            color: #ffaeae;
            text-align: center;
            margin-top: 16px;
        }
    </style>
</head>
<body>
<div class="game-container">
    <!-- account bar (minimal) -->
    <div class="account-bar">
        <span class="logo">♜ chess·min</span>
        <div class="auth-section" id="authSection"></div>
    </div>

    <!-- BIG BOARD (centered) -->
    <div class="board-wrapper">
        <div class="board" id="chessboard"></div>
    </div>

    <!-- bottom info bar: turn, captured, new game -->
    <div class="info-bar">
        <div class="turn-box" id="turnIndicator">White</div>
        <div class="captured-block">
            <div class="captured-group">
                <span class="captured-label">white</span>
                <span class="captured-pieces" id="whiteCaptured"></span>
            </div>
            <div class="captured-group">
                <span class="captured-label">black</span>
                <span class="captured-pieces" id="blackCaptured"></span>
            </div>
        </div>
        <button class="new-game-btn" id="resetGameBtn">↻ new game</button>
    </div>
    <div style="color:#888; font-size:0.9rem; margin-top:4px;" id="statusMsg"></div>
</div>

<!-- auth modal -->
<div class="modal" id="authModal">
    <div class="modal-card">
        <h2 id="modalTitle">create account</h2>
        <input type="text" id="authUsername" placeholder="username (4+)" autocomplete="off">
        <input type="password" id="authPassword" placeholder="password (4+)">
        <div class="modal-actions">
            <button id="modalSubmit">✓ ok</button>
            <button id="modalCancel">✕ cancel</button>
        </div>
        <div class="error-msg" id="authError"></div>
    </div>
</div>

<script>
    (function() {
        // ---------- FULL CHESS ENGINE (minimal, correct) ----------
        const initialBoard = [
            ['r','n','b','q','k','b','n','r'],
            ['p','p','p','p','p','p','p','p'],
            ['','','','','','','',''],
            ['','','','','','','',''],
            ['','','','','','','',''],
            ['','','','','','','',''],
            ['P','P','P','P','P','P','P','P'],
            ['R','N','B','Q','K','B','N','R']
        ];

        const pieceMap = {
            'K':'♔','Q':'♕','R':'♖','B':'♗','N':'♘','P':'♙',
            'k':'♚','q':'♛','r':'♜','b':'♝','n':'♞','p':'♟'
        };

        let board = JSON.parse(JSON.stringify(initialBoard));
        let currentTurn = 'w';
        let selectedRow = -1, selectedCol = -1;
        let legalMoves = [];
        let whiteCaptured = [];
        let blackCaptured = [];
        let gameOver = false;
        let winner = null;
        let lastMove = null;
        
        // castling rights
        let castling = {
            w: { kingMoved: false, rookA1Moved: false, rookH1Moved: false },
            b: { kingMoved: false, rookA8Moved: false, rookH8Moved: false }
        };
        let enPassantTarget = null; // { row, col }

        // ---------- account ----------
        let currentUser = null;

        function loadUserAccounts() {
            const acc = localStorage.getItem('chessMinAccounts');
            return acc ? JSON.parse(acc) : {};
        }
        function saveUserAccounts(accounts) {
            localStorage.setItem('chessMinAccounts', JSON.stringify(accounts));
        }

        function saveGameToCurrentUser() {
            if (!currentUser) return;
            const accounts = loadUserAccounts();
            if (accounts[currentUser.username]) {
                accounts[currentUser.username].gameData = {
                    board, currentTurn, whiteCaptured, blackCaptured, gameOver, winner,
                    lastMove, castling, enPassantTarget
                };
                saveUserAccounts(accounts);
                currentUser.gameData = accounts[currentUser.username].gameData;
            }
        }

        function loadGameFromUser(user) {
            if (user?.gameData) {
                board = user.gameData.board || JSON.parse(JSON.stringify(initialBoard));
                currentTurn = user.gameData.currentTurn || 'w';
                whiteCaptured = user.gameData.whiteCaptured || [];
                blackCaptured = user.gameData.blackCaptured || [];
                gameOver = user.gameData.gameOver || false;
                winner = user.gameData.winner || null;
                lastMove = user.gameData.lastMove || null;
                castling = user.gameData.castling || { w: { kingMoved: false, rookA1Moved: false, rookH1Moved: false }, b: { kingMoved: false, rookA8Moved: false, rookH8Moved: false } };
                enPassantTarget = user.gameData.enPassantTarget || null;
            } else {
                resetGameToInitial();
            }
            selectedRow = -1; legalMoves = [];
            renderBoard();
            updateUI();
        }

        function resetGameToInitial() {
            board = JSON.parse(JSON.stringify(initialBoard));
            currentTurn = 'w';
            whiteCaptured = [];
            blackCaptured = [];
            gameOver = false;
            winner = null;
            lastMove = null;
            castling = { w: { kingMoved: false, rookA1Moved: false, rookH1Moved: false }, b: { kingMoved: false, rookA8Moved: false, rookH8Moved: false } };
            enPassantTarget = null;
            selectedRow = -1; legalMoves = [];
        }

        // ---------- chess logic (complete) ----------
        function getPieceColor(piece) {
            if (!piece) return null;
            return piece === piece.toUpperCase() ? 'w' : 'b';
        }

        function isOpponent(piece, color) {
            const pc = getPieceColor(piece);
            return pc && pc !== color;
        }

        function getKingPos(color) {
            const k = color === 'w' ? 'K' : 'k';
            for (let r=0; r<8; r++) for (let c=0; c<8; c++) if (board[r][c] === k) return {r,c};
            return null;
        }

        function isAttacked(row, col, attackerColor) {
            for (let r=0; r<8; r++) {
                for (let c=0; c<8; c++) {
                    const p = board[r][c];
                    if (!p || getPieceColor(p) !== attackerColor) continue;
                    const moves = getPseudoMoves(r, c, true);
                    for (let m of moves) if (m.toRow === row && m.toCol === col) return true;
                }
            }
            return false;
        }

        function inCheck(color) {
            const k = getKingPos(color);
            return k ? isAttacked(k.r, k.c, color === 'w' ? 'b' : 'w') : false;
        }

        function getPseudoMoves(row, col, ignoreKingSafety = false) {
            const piece = board[row][col];
            if (!piece) return [];
            const color = getPieceColor(piece);
            const type = piece.toLowerCase();
            let moves = [];

            // pawn
            if (type === 'p') {
                const dir = color === 'w' ? -1 : 1;
                const startRow = color === 'w' ? 6 : 1;
                if (row+dir >=0 && row+dir<8 && !board[row+dir][col]) {
                    moves.push({ fromRow: row, fromCol: col, toRow: row+dir, toCol: col, isCapture: false, promotion: (row+dir === 0 || row+dir === 7) });
                    if (row === startRow && !board[row+2*dir][col]) {
                        moves.push({ fromRow: row, fromCol: col, toRow: row+2*dir, toCol: col, isCapture: false, isDoublePawn: true });
                    }
                }
                for (let dc of [-1,1]) {
                    const nc = col+dc;
                    if (nc>=0 && nc<8 && row+dir>=0 && row+dir<8) {
                        if (board[row+dir][nc] && isOpponent(board[row+dir][nc], color)) {
                            moves.push({ fromRow: row, fromCol: col, toRow: row+dir, toCol: nc, isCapture: true, promotion: (row+dir === 0 || row+dir === 7) });
                        }
                        if (enPassantTarget && enPassantTarget.row === row+dir && enPassantTarget.col === nc) {
                            moves.push({ fromRow: row, fromCol: col, toRow: row+dir, toCol: nc, isCapture: true, isEnPassant: true });
                        }
                    }
                }
            }
            // knight
            if (type === 'n') {
                const d = [[-2,-1],[-2,1],[-1,-2],[-1,2],[1,-2],[1,2],[2,-1],[2,1]];
                for (let [dr,dc] of d) {
                    let nr=row+dr, nc=col+dc;
                    if (nr>=0 && nr<8 && nc>=0 && nc<8 && (!board[nr][nc] || isOpponent(board[nr][nc], color))) {
                        moves.push({ fromRow: row, fromCol: col, toRow: nr, toCol: nc, isCapture: !!board[nr][nc] });
                    }
                }
            }
            // king
            if (type === 'k') {
                for (let dr=-1; dr<=1; dr++) for (let dc=-1; dc<=1; dc++) {
                    if (dr===0 && dc===0) continue;
                    let nr=row+dr, nc=col+dc;
                    if (nr>=0 && nr<8 && nc>=0 && nc<8 && (!board[nr][nc] || isOpponent(board[nr][nc], color))) {
                        moves.push({ fromRow: row, fromCol: col, toRow: nr, toCol: nc, isCapture: !!board[nr][nc] });
                    }
                }
                // castling
                if (!ignoreKingSafety && !inCheck(color)) {
                    const back = color==='w'?7:0;
                    if (row===back && col===4) {
                        if (!(color==='w'?castling.w.kingMoved:castling.b.kingMoved)) {
                            if (!board[back][5] && !board[back][6] && !(color==='w'?castling.w.rookH1Moved:castling.b.rookH8Moved) &&
                                !isAttacked(back,5,color==='w'?'b':'w') && !isAttacked(back,6,color==='w'?'b':'w')) {
                                moves.push({ fromRow: row, fromCol: col, toRow: back, toCol: 6, isCastle: true });
                            }
                            if (!board[back][3] && !board[back][2] && !board[back][1] && !(color==='w'?castling.w.rookA1Moved:castling.b.rookA8Moved) &&
                                !isAttacked(back,3,color==='w'?'b':'w') && !isAttacked(back,2,color==='w'?'b':'w')) {
                                moves.push({ fromRow: row, fromCol: col, toRow: back, toCol: 2, isCastle: true });
                            }
                        }
                    }
                }
            }
            // sliding
            if (type === 'r' || type === 'q' || type === 'b') {
                const dirs = [];
                if (type === 'r' || type === 'q') dirs.push([-1,0],[1,0],[0,-1],[0,1]);
                if (type === 'b' || type === 'q') dirs.push([-1,-1],[-1,1],[1,-1],[1,1]);
                for (let [dr,dc] of dirs) {
                    for (let i=1; i<8; i++) {
                        let nr=row+dr*i, nc=col+dc*i;
                        if (nr<0||nr>=8||nc<0||nc>=8) break;
                        if (!board[nr][nc]) moves.push({ fromRow: row, fromCol: col, toRow: nr, toCol: nc, isCapture: false });
                        else {
                            if (isOpponent(board[nr][nc], color)) moves.push({ fromRow: row, fromCol: col, toRow: nr, toCol: nc, isCapture: true });
                            break;
                        }
                    }
                }
            }
            return moves;
        }

        function getLegalMoves(row, col) {
            const pseudo = getPseudoMoves(row, col);
            const legal = [];
            const piece = board[row][col];
            if (!piece) return legal;
            const color = getPieceColor(piece);
            for (let m of pseudo) {
                const { fromRow, fromCol, toRow, toCol, isEnPassant, isCastle } = m;
                const captured = board[toRow][toCol];
                const epPawn = isEnPassant ? board[fromRow][toCol] : null;
                // apply
                board[toRow][toCol] = board[fromRow][fromCol];
                board[fromRow][fromCol] = '';
                if (isEnPassant) board[fromRow][toCol] = '';
                if (isCastle) {
                    if (toCol === 6) { board[toRow][5] = board[toRow][7]; board[toRow][7] = ''; }
                    else { board[toRow][3] = board[toRow][0]; board[toRow][0] = ''; }
                }
                const check = inCheck(color);
                // undo
                board[fromRow][fromCol] = board[toRow][toCol];
                board[toRow][toCol] = captured;
                if (isEnPassant) board[fromRow][toCol] = epPawn;
                if (isCastle) {
                    if (toCol === 6) { board[toRow][7] = board[toRow][5]; board[toRow][5] = ''; }
                    else { board[toRow][0] = board[toRow][3]; board[toRow][3] = ''; }
                }
                if (!check) legal.push(m);
            }
            return legal;
        }

        function getAllLegalMoves(color) {
            let moves = [];
            for (let r=0; r<8; r++) for (let c=0; c<8; c++) {
                if (board[r][c] && getPieceColor(board[r][c]) === color) {
                    moves.push(...getLegalMoves(r,c));
                }
            }
            return moves;
        }

        function makeMove(move) {
            const { fromRow, fromCol, toRow, toCol, isCapture, isCastle, isEnPassant, promotion } = move;
            const piece = board[fromRow][fromCol];
            const color = getPieceColor(piece);
            const captured = board[toRow][toCol];
            if (isCapture && captured) {
                (color==='w'?whiteCaptured:blackCaptured).push(pieceMap[captured]||captured);
            }
            if (isEnPassant) {
                const epPawn = board[fromRow][toCol];
                (color==='w'?whiteCaptured:blackCaptured).push(pieceMap[epPawn]||epPawn);
                board[fromRow][toCol] = '';
            }
            board[toRow][toCol] = piece;
            board[fromRow][fromCol] = '';
            if (isCastle) {
                if (toCol === 6) { board[toRow][5] = board[toRow][7]; board[toRow][7] = ''; }
                else { board[toRow][3] = board[toRow][0]; board[toRow][0] = ''; }
            }
            // update castling rights
            if (piece.toLowerCase() === 'k') {
                if (color === 'w') castling.w.kingMoved = true;
                else castling.b.kingMoved = true;
            }
            if (piece.toLowerCase() === 'r') {
                if (color==='w' && fromRow===7) {
                    if (fromCol===0) castling.w.rookA1Moved = true;
                    if (fromCol===7) castling.w.rookH1Moved = true;
                } else if (color==='b' && fromRow===0) {
                    if (fromCol===0) castling.b.rookA8Moved = true;
                    if (fromCol===7) castling.b.rookH8Moved = true;
                }
            }
            if (promotion) board[toRow][toCol] = color==='w' ? 'Q' : 'q';
            enPassantTarget = null;
            if (move.isDoublePawn) enPassantTarget = { row: (fromRow+toRow)/2, col: fromCol };
            lastMove = { fromRow, fromCol, toRow, toCol };
            currentTurn = color==='w' ? 'b' : 'w';
            const opponentMoves = getAllLegalMoves(currentTurn);
            if (opponentMoves.length === 0) {
                gameOver = true;
                winner = inCheck(currentTurn) ? color : null;
            }
        }

        // UI rendering
        function renderBoard() {
            const boardEl = document.getElementById('chessboard');
            boardEl.innerHTML = '';
            for (let r=0; r<8; r++) {
                for (let c=0; c<8; c++) {
                    const sq = document.createElement('div');
                    sq.className = `square ${(r+c)%2===0 ? 'light' : 'dark'}`;
                    sq.dataset.row = r; sq.dataset.col = c;
                    if (board[r][c]) sq.innerText = pieceMap[board[r][c]];
                    if (selectedRow===r && selectedCol===c) sq.classList.add('selected');
                    if (lastMove && ((lastMove.fromRow===r && lastMove.fromCol===c) || (lastMove.toRow===r && lastMove.toCol===c))) sq.classList.add('last-move');
                    const isLegal = legalMoves.some(m => m.toRow===r && m.toCol===c);
                    if (isLegal) {
                        sq.classList.add('legal-move');
                        if (legalMoves.find(m=>m.toRow===r && m.toCol===c)?.isCapture) sq.classList.add('legal-capture');
                    }
                    boardEl.appendChild(sq);
                }
            }
            updateUI();
        }

        function updateUI() {
            document.getElementById('turnIndicator').innerText = gameOver 
                ? (winner ? (winner==='w'?'1-0':'0-1') : '½-½')
                : (currentTurn==='w'?'White':'Black');
            document.getElementById('statusMsg').innerText = (!gameOver && inCheck(currentTurn)) ? 'CHECK' : '';
            document.getElementById('whiteCaptured').innerHTML = whiteCaptured.map(p=>`<span>${p}</span>`).join('');
            document.getElementById('blackCaptured').innerHTML = blackCaptured.map(p=>`<span>${p}</span>`).join('');
        }

        // auth UI
        function renderAuthSection() {
            const container = document.getElementById('authSection');
            if (currentUser) {
                container.innerHTML = `
                    <div class="user-badge">
                        <span class="user-icon">${currentUser.username[0].toUpperCase()}</span>
                        <span class="user-name">${currentUser.username}</span>
                        <button class="logout-btn" id="logoutBtn">logout</button>
                    </div>
                `;
                document.getElementById('logoutBtn')?.addEventListener('click', () => {
                    currentUser = null;
                    resetGameToInitial();
                    renderAuthSection();
                    renderBoard();
                });
            } else {
                container.innerHTML = `
                    <div class="auth-buttons">
                        <button class="btn" id="showLoginBtn">log in</button>
                        <button class="btn" id="showSignupBtn">sign up</button>
                    </div>
                `;
                document.getElementById('showLoginBtn')?.addEventListener('click', () => showModal('login'));
                document.getElementById('showSignupBtn')?.addEventListener('click', () => showModal('signup'));
            }
        }

        // modal
        const modal = document.getElementById('authModal');
        const modalTitle = document.getElementById('modalTitle');
        const authUser = document.getElementById('authUsername');
        const authPass = document.getElementById('authPassword');
        const authError = document.getElementById('authError');
        let modalMode = 'signup';
        function showModal(mode) {
            modalMode = mode;
            modalTitle.innerText = mode==='signup' ? 'create account' : 'log in';
            authUser.value = ''; authPass.value = ''; authError.innerText = '';
            modal.style.display = 'flex';
        }
        window.addEventListener('click', e => { if (e.target === modal) modal.style.display = 'none'; });
        document.getElementById('modalCancel').addEventListener('click', ()=>modal.style.display='none');
        document.getElementById('modalSubmit').addEventListener('click', ()=>{
            const user = authUser.value.trim();
            const pass = authPass.value.trim();
            if (user.length<4 || pass.length<4) { authError.innerText='❌ min 4 chars'; return; }
            const accounts = loadUserAccounts();
            if (modalMode==='signup') {
                if (accounts[user]) { authError.innerText='❌ exists'; return; }
                accounts[user] = { password: pass, gameData: null };
                saveUserAccounts(accounts);
                currentUser = { username: user, gameData: null };
                loadGameFromUser(currentUser);
            } else {
                if (!accounts[user] || accounts[user].password !== pass) { authError.innerText='❌ invalid'; return; }
                currentUser = { username: user, gameData: accounts[user].gameData };
                loadGameFromUser(currentUser);
            }
            modal.style.display = 'none';
            renderAuthSection();
            saveGameToCurrentUser();
        });

        // event listeners
        document.getElementById('chessboard').addEventListener('click', e => {
            const sq = e.target.closest('.square');
            if (!sq || gameOver) return;
            const row = parseInt(sq.dataset.row), col = parseInt(sq.dataset.col);
            if (selectedRow !== -1 && legalMoves.some(m => m.toRow === row && m.toCol === col)) {
                const move = legalMoves.find(m => m.toRow === row && m.toCol === col);
                makeMove(move);
                selectedRow = -1; legalMoves = [];
                saveGameToCurrentUser();
                renderBoard();
                return;
            }
            const piece = board[row][col];
            if (piece && getPieceColor(piece) === currentTurn) {
                selectedRow = row; selectedCol = col;
                legalMoves = getLegalMoves(row, col);
            } else {
                selectedRow = -1; legalMoves = [];
            }
            renderBoard();
        });

        document.getElementById('resetGameBtn').addEventListener('click', () => {
            resetGameToInitial();
            if (currentUser) saveGameToCurrentUser();
            renderBoard();
        });

        // init
        renderAuthSection();
        resetGameToInitial();
        renderBoard();
    })();
</script>
</body>
</html>
